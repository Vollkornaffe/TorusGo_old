<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - geometries</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #000;
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>
  <body>

    <script src="js/three.js"></script>

    <script src="js/Detector.js"></script>
    <script src="js/libs/stats.min.js"></script>

    <script>
      function myTorus(radius, tube, h_seg, w_seg) {
        this.params = {
          radius : radius,
          tube : tube,
          h_seg : h_seg,
          w_seg : w_seg,
          twist : 0
        };

        this.geometry = new THREE.Geometry();

        var x_ax = new THREE.Vector3(1,0,0);
        var y_ax = new THREE.Vector3(0,1,0);
        for (var i = 0; i < w_seg; i++) {
          var i_rad = i/w_seg * 2 * Math.PI;
          var offset = new THREE.Vector3(
            tube * Math.cos(i_rad),
            tube * Math.sin(i_rad),
            0
          );
          
          for (var j = 0; j < h_seg; j++) {
            var j_rad = j/w_seg * 2 * Math.PI;
            var newPos = new THREE.Vector3();
            newPos.copy(offset);
            newPos.addScaledVector(y_ax, radius);
            newPos.applyAxisAngle(x_ax, j_rad);

            this.geometry.vertices.push(newPos);

            // gen faces
            var thisIdx = i * w_seg + j;
            if (i !== 0 && j !== 0) {
              this.geometry.faces.push(new THREE.Face3(thisIdx, thisIdx - 1, thisIdx - h_seg));
              this.geometry.faces.push(new THREE.Face3(thisIdx - 1, thisIdx - h_seg, thisIdx - 1 - h_seg));
              if (j === h_seg - 1) {
                this.geometry.faces.push(new THREE.Face3(thisIdx - h_seg + 1, thisIdx, thisIdx - h_seg - h_seg + 1));
                this.geometry.faces.push(new THREE.Face3(thisIdx, thisIdx - h_seg - h_seg + 1,  thisIdx - h_seg));
              }
              if (i === w_seg - 1) {
                this.geometry.faces.push(new THREE.Face3(j, j - 1, thisIdx));
                this.geometry.faces.push(new THREE.Face3(j - 1, thisIdx, thisIdx - 1));
              }
              if (i === w_seg - 1 && j === h_seg - 1) {
                this.geometry.faces.push(new THREE.Face3(0, j, thisIdx - h_seg + 1));
                this.geometry.faces.push(new THREE.Face3(j, thisIdx - h_seg + 1, thisIdx));
              }
            }
          }
        }

        this.geometry.computeBoundingSphere();

        this.geometry.dynamic = true;

        this.mesh = new THREE.Mesh(this.geometry, boardMaterial);
        this.mesh.position.set(0,0,0);       
      }

      function twistTorus(torus, rad) {

        torus.mesh.geometry.dynamic = true;
        torus.params.twist += rad;

        var x_ax = new THREE.Vector3(1,0,0);
        var y_ax = new THREE.Vector3(0,1,0);

        for (var i = 0; i < torus.params.w_seg; i++) {
          var i_rad = i/torus.params.w_seg * 2 * Math.PI + torus.params.twist;
          var offset = new THREE.Vector3(
            torus.params.tube * Math.cos(i_rad),
            torus.params.tube * Math.sin(i_rad),
            0
          );
          
          for (var j = 0; j < torus.params.h_seg; j++) {
            var j_rad = j/torus.params.w_seg * 2 * Math.PI;
            var newPos = new THREE.Vector3();
            newPos.copy(offset);
            newPos.addScaledVector(y_ax, torus.params.radius);
            newPos.applyAxisAngle(x_ax, j_rad);

            var thisIdx = i * torus.params.w_seg + j;
            torus.mesh.geometry.vertices[thisIdx].copy(newPos);            
          }
        }

        torus.mesh.geometry.verticesNeedUpdate = true;
      }
    </script>

    <script>
      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
      var container, stats;
      var camera, scene, renderer;
      var mesh, geometry;
      var d_mesh, d_geometry;
      var mytorus;

      var boardMaterial, whiteMaterial, blackMaterial;
      
      var nextIndex = 0;

      var clock = new THREE.Clock();

      init();
      animate();
      function init() {
        container = document.createElement( 'div' );
        document.body.appendChild( container );
        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
        camera.position.y = 0;
        scene = new THREE.Scene();
        var light, object;
        scene.add( new THREE.AmbientLight( 0x404040 ) );
        light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 1, 1, 1 );
        scene.add( light );
        //
        boardMaterial = new THREE.MeshPhongMaterial( { color: 0xc7aa52, shading: THREE.FlatShading, overdraw: 0.5, shininess: 0 , side : THREE.DoubleSide} );
        whiteMaterial = new THREE.MeshPhongMaterial( { color: 0xdbdad6, shading: THREE.FlatShading, overdraw: 0.5, shininess: 0 , side : THREE.DoubleSide} );
        blackMaterial = new THREE.MeshPhongMaterial( { color: 0x20201d, shading: THREE.FlatShading, overdraw: 0.5, shininess: 0 , side : THREE.DoubleSide} );
        // 
        mytorus = new myTorus(100,30,20,20);
        console.log(mytorus.geometry.vertices.length);
        console.log(mytorus.geometry.faces.length);

        scene.add(mytorus.mesh);

        object = new THREE.AxisHelper( 50 );
        object.position.set( 0, 0, 0 );
        scene.add( object );
        //
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );
        stats = new Stats();
        container.appendChild( stats.dom );
        //
        window.addEventListener( 'resize', onWindowResize, false );
      }
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
      }
      //
      function animate() {
        requestAnimationFrame( animate );
        render();
        stats.update();
      }
      function render() {

        var delta = clock.getDelta();
        var time = clock.getElapsedTime() * 10;
        var timer = Date.now() * 0.0001;
        camera.position.x = Math.cos( timer ) * 300;
        camera.position.z = Math.sin( timer ) * 300;
        camera.lookAt( scene.position );

        if (mytorus.mesh !== undefined) {
          twistTorus(mytorus, 0.01);
        }

        renderer.render( scene, camera );
      }
    </script>

  </body>
</html>
